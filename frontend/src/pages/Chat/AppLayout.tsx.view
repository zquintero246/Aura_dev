// AppLayout.tsximport React, { useEffect, useMemo, useState } from 'react';import IconRail from './IconRail';import ConversationsPanel, { Conversation } from './ConversationsPanel';import GroupsPanel, { Group } from './GroupsPanel';import MainPanel from './MainPanel';import ProfilePanel from '../Account/Profile';import ChatPanel from './ChatPanel';import { me, logout, User } from '../../lib/auth';import { useNavigate } from 'react-router-dom';import { listConversations, createConversation } from '../../lib/conversations';type SectionKey = 'chats' | 'group' | 'project' | 'telemetry';type Selection =  | { type: 'chat'; id: string }  | { type: 'group'; id: string }  | { type: 'project'; id: string }  | { type: 'telemetry'; view: 'overview' | 'errors' | 'latency' }  | { type: 'profile' }  | null;const RAIL_W = 72;const SIDE_W = 320;export default function AppLayout() {  const navigate = useNavigate();  const [activeRail, setActiveRail] = useState<SectionKey>('chats');  const [conversationsOpen, setConversationsOpen] = useState(true);  const [selection, setSelection] = useState<Selection>(null);  // Sin conversaciones por defecto; se cargan desde backend  const [pinned, setPinned] = useState<Conversation[]>([]);  const [recent, setRecent] = useState<Conversation[]>([]);  // Grupos (demo)  const [myGroups] = useState<Group[]>([    { id: 'g1', name: 'Equipo Backend', members: 12, unread: 3 },    { id: 'g2', name: 'Diseño UX', members: 7 },  ]);  const [explore] = useState<Group[]>([    { id: 'g3', name: 'IA & LLMs', members: 56 },    { id: 'g4', name: 'DevOps Lovers', members: 31, unread: 1 },  ]);  const mainPaddingLeft = useMemo(() => {    const side =      activeRail === 'chats'        ? conversationsOpen          ? SIDE_W          : 0        : activeRail === 'group'        ? SIDE_W        : 0;    return `${RAIL_W + side}px`;  }, [activeRail, conversationsOpen]);  // Crear conversación (persistente)  const handleCreateChat = async () => {    const tempId = `tmp-${crypto.randomUUID()}`;    const tempConv: Conversation = { id: tempId, title: 'Nueva conversación' };    setRecent((r) => [tempConv, ...r]);    setSelection({ type: 'chat', id: tempId });    try {      const conv = await createConversation('Nueva conversación');      setRecent((r) => [conv, ...r.filter((c) => c.id !== tempId)]);      setSelection({ type: 'chat', id: conv.id });    } catch {      // dejamos la temporal; usuario puede reintentar    }  };  const handleSearchChat = (q: string) => {    console.log('buscar chat:', q);  };  const handleChatTitleChange = (id: string, newTitle: string) => {    setPinned((prev) => prev.map((c) => (c.id === id ? { ...c, title: newTitle } : c)));    setRecent((prev) => prev.map((c) => (c.id === id ? { ...c, title: newTitle } : c)));  };  // Pin/unpin con límite 3  const handleTogglePin = (id: string, nextPinned: boolean) => {    if (nextPinned) {      if (pinned.length >= 3) {        try { window.alert('Solo puedes anclar hasta 3 conversaciones'); } catch {}        return;      }      const item = recent.find((c) => c.id === id);      if (item && !pinned.find((p) => p.id === id)) {        setRecent((r) => r.filter((c) => c.id !== id));        setPinned((p) => [...p, { ...item, pinned: true }]);      }    } else {      const item = pinned.find((c) => c.id === id);      if (item) {        setPinned((p) => p.filter((c) => c.id !== id));        setRecent((r) => [{ ...item, pinned: false }, ...r.filter((c) => c.id !== id)]);      }    }  };  const activeChat =    (selection?.type === 'chat' &&      (pinned.find((c) => c.id === selection.id) || recent.find((c) => c.id === selection.id))) ||    null;  // Sesión de usuario  const [user, setUser] = useState<User | null>(null);  useEffect(() => {    (async () => {      try {        const res = await me();        setUser(res?.user || null);      } catch {        setUser(null);      }    })();  }, []);